name: Deploy Infrastructure

on:
  push:
    branches: [main]
    paths:
      - "networking/**"
      - "data-layer/**"
      - ".github/workflows/deploy.yml"
  workflow_dispatch:

env:
  AKS_RESOURCE_GROUP: teleios-dupe-rg
  AKS_CLUSTER_NAME: rideshare-aks-cluster
  NAMESPACE: rideshare

jobs:
  deploy-infrastructure:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Azure Login
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Install kubectl and set AKS context
        run: |
          az aks install-cli
          az aks get-credentials \
            --resource-group ${{ env.AKS_RESOURCE_GROUP }} \
            --name ${{ env.AKS_CLUSTER_NAME }} \
            --overwrite-existing
          kubelogin convert-kubeconfig -l azurecli

      - name: Validate manifests
        run: |
          echo "Validating Kubernetes manifests..."
          kubectl --dry-run=client apply -f storage-classes.yaml
          kubectl --dry-run=client apply -f data-layer/
          kubectl --dry-run=client apply -f networking/ingress-rules.yaml

      - name: Create shared secrets
        run: |
          kubectl create secret generic rideshare-secrets \
            --from-literal=USER_DATABASE_URL=${{ secrets.USER_DATABASE_URL }} \
            --from-literal=REDIS_URL=${{ secrets.REDIS_URL }} \
            --from-literal=JWT_SECRET_KEY=${{ secrets.JWT_SECRET_KEY }} \
            --dry-run=client -o yaml | kubectl apply -f - -n ${{ env.NAMESPACE }}

      - name: Create microservice secrets
        run: |
          kubectl create secret generic user-service-secrets \
            --from-literal=USER_DATABASE_URL=${{ secrets.USER_DATABASE_URL }} \
            --dry-run=client -o yaml | kubectl apply -f - -n ${{ env.NAMESPACE }}

          kubectl create secret generic payment-service-secrets \
            --from-literal=PAYMENT_DATABASE_URL=${{ secrets.PAYMENT_DATABASE_URL }} \
            --dry-run=client -o yaml | kubectl apply -f - -n ${{ env.NAMESPACE }}

          kubectl create secret generic ride-matching-service-secrets \
            --from-literal=RIDES_DATABASE_URL=${{ secrets.RIDES_DATABASE_URL }} \
            --from-literal=JWT_SECRET_KEY=${{ secrets.JWT_SECRET_KEY }} \
            --dry-run=client -o yaml | kubectl apply -f - -n ${{ env.NAMESPACE }}

          kubectl create secret generic notification-service-secrets \
            --from-literal=NOTIFY_DATABASE_URL=${{ secrets.NOTIFY_DATABASE_URL }} \
            --from-literal=JWT_SECRET_KEY=${{ secrets.JWT_SECRET_KEY }} \
            --from-literal=REDIS_URL=${{ secrets.REDIS_URL }} \
            --from-literal=SENDGRID_API_KEY=${{ secrets.SENDGRID_API_KEY }} \
            --from-literal=SENDGRID_FROM_EMAIL=${{ secrets.SENDGRID_FROM_EMAIL }} \
            --from-literal=FIREBASE_PROJECT_ID=${{ secrets.FIREBASE_PROJECT_ID }} \
            --from-literal=FIREBASE_CREDENTIALS_PATH=${{ secrets.FIREBASE_CREDENTIALS_PATH }} \
            --dry-run=client -o yaml | kubectl apply -f - -n ${{ env.NAMESPACE }}

      - name: Apply ingress rules
        run: kubectl apply -f networking/ingress-rules.yaml -n ${{ env.NAMESPACE }}

      - name: Deploy microservice workloads
        run: |
          kubectl apply -f rideshare-user-service/k8s/deployment.yaml -n ${{ env.NAMESPACE }}
          kubectl apply -f rideshare-payment-service/k8s/deployment.yaml -n ${{ env.NAMESPACE }}
          kubectl apply -f rideshare-ride-matching-service/k8s/deployment.yaml -n ${{ env.NAMESPACE }}
          kubectl apply -f rideshare-notification-service/k8s/deployment.yaml -n ${{ env.NAMESPACE }}

      # - name: Rollout status checks
      #   run: |
      #     kubectl rollout status deployment/user-service -n ${{ env.NAMESPACE }} --timeout=180s
      #     kubectl rollout status deployment/payment-service -n ${{ env.NAMESPACE }} --timeout=180s
      #     kubectl rollout status deployment/ride-matching-service -n ${{ env.NAMESPACE }} --timeout=180s
      #     kubectl rollout status deployment/notification-service -n ${{ env.NAMESPACE }} --timeout=180s

  setup-frontdoor:
    runs-on: ubuntu-latest
    if: github.event_name == 'workflow_dispatch'

    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Azure Login
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Setup Azure Front Door
        run: |
          chmod +x azure-setup/configure-frontdoor.sh
          azure-setup/configure-frontdoor.sh
